# Рассчётная работа 
## Вариант 6.4

**Базовые определения:**
**Гомеоморфизм** - два графа гомеоморфны (или тождественны с точностью до вершин степени 2),если они оба могут быть получены из одного и того же графа «включением» в его ребра новых вершин степени 2.Если ребро графа изображено в виде линии, то можно на ней поставить точку и считать ее новой вершиной степени 2.

**Граф** – это топологичекая модель, которая состоит из множества вершин и множества соединяющих их рёбер. При этом значение имеет только сам факт, какая вершина с какой соединена.

**Инцидентность** (смежность) – отношение между двумя вершинами, в котором существует ребро их соединяющее.

**Концевые вершины графа** - вершины, соединяющие данное множество ребер.

**Мост** - ребро, после удаления которого, граф распадается на две компоненты связности

**Планарность** - свойство графа, которое возникает, если существует укладка взятого графа на плоскости.

**Плоский граф** - граф, изображенный на плоскости так, что никакие два ребра не имеют общих точек, кроме инцидентной им обоим вершины.

**Подграф** - это часть графа, в которой мы берем некоторые его вершины и ребра. Другими словами, граф H является подграфом графа G, если вершины и ребра H являются подмножеством вершин и ребер G.

**Связный граф** - граф, содержащий ровно одну компоненту связности. Это означает, что между любой парой вершин этого графа существует как минимум один путь.

**Сегмент** - компонент связности графа с его подграфом.

**Укладка графа** - такое его геометрическое изображение, при котором ребра графа пересекаются только в вершинах.

## Цель данной работы:

Реализовать один из алгоритмов для выявления планарности графа и посчета ребер, которые необходимо удалить для получения планарного графа, с использованием языка программирования С++
Исследовать работу алгоритма и описать её
## Обзор существующих методов для выявления планарности:
**Теорема Понтрягина-Куратовского** - доказывает, что граф планарен тогда и только тогда, когда он не содержит подграфов, гомеоморфных K5 или K3,3. Так как этот критерий очень трудно проверить на практике, данная теорема представляет лишь теоретический интерес.
**Гамма алгоритм** – алгоритм, основанный на теореме Понтрягина-Куратовского, с помощью которого удобнее всего проверить граф на планарность и уложить его на плоскости.
Воспользуемся гамма-алгоритмом, так как он проще в реализации.
## Описание алгоритма:
**Входные данные**
На вход алгоритму подаются графы со следующими свойствами:

Граф связный.
*Если нарушено свойство, то граф нужно укладывать отдельно по компонентам связности.*

Граф содержит хотя бы один цикл.
*Если нарушено свойство , то граф — дерево и нарисовать его плоскую укладку тривиально.*

Граф не имеет мостов.

*Случай нарушения данного свойства рассмотрим более подробно. Если в графе есть мосты, то их нужно разрезать, провести отдельно плоскую укладку каждой компоненты связности, а затем соединить их мостами. Здесь может возникнуть трудность: в процессе укладки концевые вершины моста могут оказаться внутри плоского графа. Нарисуем одну компоненту связности, и будем присоединять к ней другие последовательно. Каждую новую компоненту связности будем рисовать в той грани, в которой лежит концевая вершина соответствующего моста. Так как граф связности мостами компонент связности является деревом, мы сумеем получить плоскую укладку.*
## Инициализация алгоритма:
Пусть дан граф G (см. рис. 1):
<image src="/Снимок экрана 2024-12-10 215130.png" alt="Рисунок 1">

Выбираем любой простой цикл в G, пусть это будет {1, 2, 3, 4, 5, 6}, укладываем его на плоскости, и получаем две грани: Г1 — внешнюю и Г2 — внутреннюю (см. рис. 2).

<image src="/Снимок экрана 2024-12-10 220330.png" alt="Рисунок 2">


Уже уложенную часть исходного графа будем обозначать как G′, тогда после первого шага G′ представляет собой цикл {1, 2, 3, 4, 5, 6}.

На каждом шаге будем строить множество сегментов. Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:

ребро, оба конца которого принадлежат G′, но само оно не принадлежит G′;
связную компоненту графа G – G′, дополненную всеми ребрами графа G, один из концов которых принадлежит связной компоненте, а второй из графа G′.
Вершины, которые одновременно принадлежат G′ и какому-то сегменту, назовем контактными вершинами. Для нашего примера сегменты изображены на рис. 3. Контактные вершины обведены в квадрат.

<image src="/Снимок экрана 2024-12-10 220355.png" alt="Рисунок 3">

Если все контактные вершины сегмента S имеют номера вершин какой-то грани Г, то мы будем говорить, что грань Г вмещает этот сегмент, в этом случае будем использовать следующее обозначение: S Г. Однако, может быть так, что не одна грань вмещает в себя сегмент S, а несколько. Множество таких граней обозначим Г(S), а их число |Г(S)|.

**Общий шаг**
Выделяются все сегменты Si и определяются числа |Г(Si)|. Если хоть одно из них равно 0, то граф не планарен, конец. Иначе, выбираем сегмент, для которого число |Г(S)| минимально, или любой из них, если таких сегментов несколько. В этом сегменте найдем произвольную цепь между двумя контактными вершинами и уложим ее в любую из граней множества Г(S). При этом данная грань разобьется на две. Уже уложенная часть графа G’ после укладки цепи увеличится, а сегмент, из которого вынута цепь, исчезнет или развалится на меньшие с новыми контактными вершинами, ведущими к вершинам G′.

В результате повторения общего шага будет либо получена плоская укладка, когда множество сегментов станет пустым, либо будет получено, что граф G не является планарным.

Вернемся к нашему примеру. Пока для любого i: Si {Г1, Г2}, |Г(Si)| = 2. Поэтому возьмем первый по номеру сегмент Si и в нем цепь {1, 4}; вставим эту цепь в грань Г2. После укладки цепи G’ увеличится и произойдут изменения в структуре сегментов (см. рис. 4, 5).

<image src="/Снимок экрана 2024-12-10 221005.png" alt="Рисунок 4">

<image src="/Снимок экрана 2024-12-10 221024.png" alt="Рисунок 5">

Определим, какие грани вмещают новые сегменты. Теперь сегменты S1 и S3 можно уложить только в одну грань Г1, в то время как сегменты S2 и S4 можно уложить в две грани (для S2 это грани Г1 и Г2, для S4 - Г1 и Г3). Поэтому берем S1. Возьмем в нем цепь {2, 5} и уложим ее в Г1. Получим увеличенный граф G′ и уменьшенную систему сегментов (см. рис. 6, 7).

<image src="/Снимок экрана 2024-12-10 221044.png" alt="Рисунок 6">

<image src="/Снимок экрана 2024-12-10 221156.png" alt="Рисунок 7">

## Завершение работы
Продолжая таким образом, в итоге получим плоскую укладку исходного графа G(см. рис. 8).

<image src="/Снимок экрана 2024-12-10 221216.png" alt="Рисунок 8">

# Заключение
В результате проведённой работы удалось:

1. Изучить материалы по методам укладки планарного графа
2. Выбрать алгоритм решения данной задачи и реализовать на языке С++
3. Выполнить иследование выбранного алгоритма на производительность и эффективность
